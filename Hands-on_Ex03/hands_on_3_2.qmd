---
title: "Hands On Exercise 3.2: 2nd Order Spatial Point Patterns Analysis Methods"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      message = FALSE,
                      warning = FALSE)
```

## Overview

Let's start with learning what spatial point analysis is. Spatial point analysis is the evaluation of a pattern or distribution of a set points referring to location on a surface. These points can be the location of: - An event (crime, accident, disease, etc) - A business service (coffee shop, supermarket, etc)

In this lesson, we will be using the [spatstat](https://cran.r-project.org/web/packages/spatstat/) library to answer these questions:

-   are the childcare centres in Singapore randomly distributed throughout the country?
-   if the answer is not, then the next logical question is where are the locations with higher concentration of childcare centres?

## Datasets

There are 3 datasets to be used - CHILDCARE, a point feature data providing both location and attribute information of childcare centres. It was downloaded from [data.gov.sg](https://data.gov.sg/) and is in geojson format. - MP14_SUBZONE_WEB_PL, a polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data. It is in ESRI shapefile format. This data set was also downloaded from [data.gov.sg](https://data.gov.sg/). - CostalOutline, a polygon feature data showing the national boundary of Singapore. It is provided by SLA and is in ESRI shapefile format.

## Packages Setup

We are using 5 packages: - sf for processing geospatial data in R - spatstat for point pattern analysis - raster for processing gridded spatial data. We will use raster to convert the image output from spatsat to a raster format - maptools for manipulating geospatial data. We mainly use it to conver spatial data into ppp format of spatstat - tmap to plot point pattern maps

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)

```

## Spatial Data Wrangling

### Importing Data

We are using st_read() and st_transform() to load 3 data sets to R

```{r}
#Childcare Data
childcare_sf <- st_read("../Hands-on_Ex03/data/ChildCareServices.geojson") |> st_transform(crs=3414)

```

```{r}
#Coastal Outline
sg_sf <- st_read('../Hands-on_Ex03/data', layer='CostalOutline')

```

```{r}
#MPSZ
mpsz_sf <- st_read('../Hands-on_Ex03/data', layer='MP14_SUBZONE_WEB_PL')
```

### Retrieve the referencing system information of these geospatial data

We can use st_crs() to retrieve the referencing system information
```{r}
st_crs(childcare_sf)
st_crs(mpsz_sf)
st_crs(sg_sf)
```

We can see that childcare_sf is in WGS84, while mpsz_sf and sg_sf is in SVY21. To address this, we can use the st_transform()
```{r}
mpsz_sf <- st_transform(mpsz_sf, crs= 3414)
sg_sf <- st_transform(sg_sf, crs= 3414)
```

Now let's check their new referencing system information
```{r}
st_crs(mpsz_sf)
st_crs(sg_sf)
```

### Mapping The Data
To see their spatial patterns, we can explore plotting the data using tmap functions

```{r}
tmap_options(check.and.fix = TRUE)
tm_shape(sg_sf) + tm_polygons() +
  tm_shape(mpsz_sf) + tm_polygons() + 
    tm_shape(childcare_sf) + tm_dots()
```
## Geospatial Data Wrangling
We have experienced the use of simple feature data frames. However, sometimes we need to use the data in a sp's Spatial* classes

### Converting sf data frames to sp's Spatial* class
We will be using as_Spatial() function from sf package

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

To display the information of these 3 spatial classes:

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```
### Converting Spatial* class to generic sp format
spatstat requires the data to be in ppp object form. However, there is no direct way to convert Spatial* class to ppp object. So, we need to convert it to Spatial objects first

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

To show the object properties
```{r}
childcare_sp
```

```{r}
sg_sp
```

### Converting Generic sp Format to spatstat's ppp Format

```{r}
childcare_ppp <- as(childcare_sp, 'ppp')
childcare_ppp
```
Let's see what the difference is in a plot
```{r}
plot(childcare_ppp)
```

To get the summary statistics, we can use this code
```{r}
summary(childcare_ppp)
```
### Handling duplicated points

We can check if there are any duplicates with this
```{r}
any(duplicated(childcare_ppp))
```
To count the number of co-incidence points, we can use the multiplicity() function
```{r}
multiplicity(childcare_ppp)
```
To see how many locations have more than one point event, sum up the multiplicity
```{r}
sum(multiplicity(childcare_ppp) > 1)
```
Now, we can plot out where these duplicate point events are

```{r}
tmap_mode('view')
tm_shape(childcare) + tm_dots(alpha=0.4, size=0.05)
```

```{r}
#Change back the mode to 'plot' to save up on resources
tmap_mode('plot')
```

To overcome duplicates, there are three main ways:
1. Delete the duplicates: loss of useful point events
2. Jittering: add a small perturbation to the duplicate points so that they do not occupy the exact same space
3.  Make each point “unique” and then attach the duplicates of the points to the patterns as marks, as attributes of the points. Then you would need analytical techniques that take into account these marks

This code chunk implements the jittering approach
```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

After implementing the jittering approach, let's see if there are still any duplicates
```{r}
any(duplicated(childcare_ppp_jit))
```

## owin Object
An owin object is specially designed to represent a certain polygonal region that we are analysing (e.g. Singapore). The code chunk below converts sg SpatialPolygon object into an owin object of spatstat
```{r}
sg_owin <- as(sg_sp, 'owin')
```

Let's see what it looks like by plotting it
```{r}
plot(sg_owin)
```
### Combining point events object and owin object
```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
```

```{r}
summary(childcareSG_ppp)
```

Now, we can try to plot it out
```{r}
plot(childcareSG_ppp)
```


## Second-Order Spatial Point Pattern Analysis

Before going to the analysis, we need to extract the study area
```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```
Plot it to check
```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```
Convert it into sp format
```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```
Then, create the owin object
```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```
And extract the childcare within the region
```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Rescale it to kilometre
```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```
Plot the location of the childcare centres
```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```


### G-Function
The G function measures the distribution of the distances from an arbitrary event to its nearest event. We will be learning how to compute G-function estimation using Gest() from the spatstat package, and perform monte carlo simulation using envelope() from spatstat.

#### Choa Chu Kang Planning Area

First, we use Gest() to compute the G-function
```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```
To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```
```{r}
plot(G_CK.csr)
```

### Tampines Planning Area

First, we use Gest() to compute the G-function
```{r}
G_tm = Gest(childcare_tm_ppp, correction = "border")
plot(G_tm, xlim=c(0,500))
```

To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, nsim = 999)
```

```{r}
plot(G_tm.csr)
```

### F-Function
The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape. We will be learning how to compute F-function estimation using Fest() from the spatstat package, and perform monte carlo simulation using envelope() from spatstat.

#### Choa Chu Kang Planning Area

First, we use Fest() to compute the F-function
```{r}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
plot(F_CK.csr)
```

#### Tampines Planning Area

First, we use Fest() to compute the F-function
```{r}
F_tm = Fest(childcare_tm_ppp)
plot(F_tm)
```

To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, nsim = 999)
plot(F_tm.csr)
```
### K-Function
K-function measures the number of events found up to a given distance of any particular event. We will be learning how to compute K-function estimation using Kest() from the spatstat package, and perform monte carlo simulation using envelope() from spatstat.

#### Choa Chu Kang Planning Area

First, we use Kest() to compute the K-function
```{r}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
K_CK.csr <- envelope(childcare_ck_ppp, Kest, nsim = 999)
plot(K_CK.csr)
```

#### Tampines Planning Area

First, we use Kest() to compute the K-function
```{r}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 999)
plot(K_tm.csr)
```


### L-Function
We will be learning how to compute K-function estimation using Lest() from the spatstat package, and perform monte carlo simulation using envelope() from spatstat.

#### Choa Chu Kang Planning Area

First, we use Lest() to compute the L-function
```{r}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```

To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
L_CK.csr <- envelope(childcare_ck_ppp, Lest, nsim = 999)
plot(K_CK.csr)
```

#### Tampines Planning Area

First, we use Lest() to compute the K-function
```{r}
L_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, ylab= "L(d)-r", xlab = "d(m)")
```

To confirm the spatial pattern that we observe above, we can do a hypothesis testing

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

alpha-value = 0.001

Now we perform a monte carlo test
```{r}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 999)
plot(L_tm.csr)
```