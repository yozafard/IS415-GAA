---
title: "Take-home Exercise 1: Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore"
author: "Yozafard Harold Siauheming"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      message = TRUE,
                      warning = FALSE,
                      fig.retina = 3)
```

#1. Overview 

## 1.1 Background Human mobility, the movement of human beings in space and time, reflects the spatial-temporal characteristics of human behavior. With the advancement Information and Communication Technologies (ICT) especially smart phone, a large volume of data related to human mobility have been collected. By using appropriate GIS analysis methods, these data are potentially useful in supporting smart city planning and management.

In Singapore, one of the important source of data related to human mobility is from [Land Transport Authority (LTA) DataMall](https://datamall.lta.gov.sg/content/datamall/en.html). Two data sets related to human mobility are provided by the portal, they are: Passenger Volume by Origin Destination Train Stations and Passenger Volume by Origin Destination Bus Stops. One of the limitation of these data sets is that their location are biased to either bus stops or MRT/LRT stations. In 2020, another very interesting human mobility data set called [Grab Posisi](https://engineering.grab.com/grab-posisi) was released by GRAB, one of the largest shared taxi operator in South-east Asia. There are two data sets been released and one of them is for Singapore.

## 1.2 Objectives

Geospatial analytics hold tremendous potential to address complex problems facing society. In this study, you are tasked to apply appropriate spatial point patterns analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore.

## 1.3 Tasks

The specific tasks of this take-home exercise are as follows:

-   Using appropriate function of sf and tidyverse, preparing the following geospatial data layer in sf tibble data.frames:
    -   Grab taxi location points either by origins or destinations.
    -   Road layer within Singapore excluding outer islands.
    -   Singapore boundary layer excluding outer islands

-   Using the extracted data, derive traditional Kernel Density Estimation layers.

-   Using the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE)

-   Using appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore.

-   Describe the spatial patterns revealed by the kernel density maps.

# 2. Packages

The R packages used in this project are: 
  - sf: for importing, managing, and processing geospatial data. 
  - tidyverse: a family of other R packages for performing data science tasks such as importing, wrangling, and visualising data. 
  - tmap: creating thematic maps - maptools: a set of tools for manipulating geographic data 
  - raster: reads, writes, manipulates, analyses, and model gridded spatial data (raster) 
  - spatstat: for performing spatial point patterns analysis 
  - spNetwork: for performing spatial analysis on network 
  - arrow: to read parquet files
  - data.table: to manipulate large tables faster

We can load these packages with this code chunk:

```{r}
pacman::p_load(sf, spNetwork, tmap, arrow, tidyverse, spatstat, maptools, data.table, raster)
```

# 3. Data

Aspatial: - [Grab-Posisi](https://engineering.grab.com/grab-posisi) Singapore

Geospatial: - Road data from OpenStreetMap of Geofabrik download server, - Master Plan 2019 Subzone Boundary (No Sea) [from Data.gov.sg](data.gov.sg)

## 3.1 Loading datasets

### 3.1.1 Grab-Posisi

We can load all the Grab-Posisi datasets with this code chunk:

```{r}
file_list <- list.files('./data/GrabPosisi')

combined <- list()
for(i in seq(file_list)) {
  data_name <- paste0('grabposisi', i - 1)
  temp <- read_parquet(paste0('data/GrabPosisi/', file_list[i]))
  combined[[i]] <- temp
}

#Combine all datasets
grabposisi <- bind_rows(combined)
```

What the code chunk above does, is that it takes in the names of the files in the specified folder, turning it into a list. 

Now, we explore the grabposisi data

```{r}
glimpse(grabposisi)
```

We noticed that pingtimestamp is an integer field, so we need to convert pingtimestamp field to a datetime format (POCIXCT)

```{r}
grabposisi$pingtimestamp <- as_datetime(grabposisi$pingtimestamp)
```


Now, we can extract the origin of a ride, based on trajectory id. We will group the rows based on trajectory id, and sort it in ascending order based on the timestamp. The first index of every trajectory id will be the starting point of that ride. After the extraction, we can use use st_as_sf() to convert it into an sf, with the parameter crs=4326 as the dataset is taken from GPS data, which typically uses the WGS-84. However, we need to use st_transform to set the crs to 3414, which is used in Singapore.

```{r}
# Convert your df object to a data.table
setDT(grabposisi)

# Pre-calculate date parts to avoid calling them for each row inside mutate
grabposisi[, `:=`(
  weekday = wday(pingtimestamp),
  starting_hour = factor(hour(pingtimestamp)),
  day = factor(mday(pingtimestamp))
)]

# Perform the operations (group, arrange, and filter)
origin <- grabposisi[order(trj_id, pingtimestamp)
  ][, .SD[1], by = .(trj_id)
  ] |> st_as_sf(coords=c("rawlng", "rawlat"), crs=4326) |> st_transform(3414)

st_crs(origin)
```

Let's filter so that we only have cars in the data
```{r}
origin <- filter(origin, driving_mode == 'car')

```

Now, we can see what it looks like
```{r}
qtm(origin)
```

We can apply a similar logic to get the destination. The difference is that we need to sort it in descending order based on the timestamp.

```{r}
# Convert your df object to a data.table
setDT(grabposisi)

# Pre-calculate date parts to avoid calling them for each row inside mutate
grabposisi[, `:=`(
  weekday = wday(pingtimestamp),
  starting_hour = factor(hour(pingtimestamp)),
  day = factor(mday(pingtimestamp))
)]

# Perform the operations (group, arrange, and filter)
destination <- grabposisi[order(trj_id, -pingtimestamp)
  ][, .SD[1], by = .(trj_id)
  ] |> st_as_sf(coords=c("rawlng", "rawlat"), crs=4326) |> st_transform(3414)

st_crs(destination)
```

Same as above, we can filter it
```{r}
destination <- filter(destination, driving_mode == 'car')

```

And plot it
```{r}
qtm(destination)
```


### 3.1.2 Geospatial Data

#### 3.1.2.1 MPSZ
Now, we need to load the geospatial data. Let's start with the 2019 Subzone Master Plan

```{r}
mpsz2019_sf <- st_read(dsn='data/Geospatial/MPSZ-2019', layer='MPSZ-2019') |> st_transform(crs=3414)
st_crs(mpsz2019_sf)
```

And see what it looks like on a plot.
```{r}
qtm(mpsz2019_sf)
```
Notice that this includes the surrounding islands. To extract only the main island, we can filter out the surrounding islands with this code chunk below. The !grepl() function will find any of the rows that doesn't include "ISLAND" in their PLN_AREA_N column. You can see the difference between the plots

```{r}
mpsz2019_sf <- mpsz2019_sf[!grepl("ISLAND", mpsz2019_sf$PLN_AREA_N, ignore.case = TRUE), ]
qtm(mpsz2019_sf)
```

Now, we can get the outline of Singapore's main island with st_union()
```{r}
sg_sf <- mpsz2019_sf |> st_union()
plot(sg_sf)

```
#### 3.1.2.2 Road Data

After the Master Plan, we can move on to the Road Data Set

```{r}
road_sf <- st_read(dsn = 'data/Geospatial/malaysia-singapore-brunei-latest-free.shp', layer='gis_osm_roads_free_1') |> st_transform(crs=3414)
st_crs(road_sf)
glimpse(road_sf)
```
## 3.2 Converting to PPP

Since KDE requires the point data to be in ppp format, we will convert our origin and destination to ppp. To do this, we can convert it into a Spatial* object with as_Spatial(), then to an sp object with as(x, 'SpatialPoints'), then finally to ppp with as(x, 'ppp')
```{r}
origin_spatial <- as_Spatial(origin)
origin_sp <- as(origin_spatial, 'SpatialPoints')
origin_ppp <- as(origin_sp, 'ppp')

destination_spatial <- as_Spatial(destination)
destination_sp <- as(destination_spatial, 'SpatialPoints')
destination_ppp <- as(destination_sp, 'ppp')

#Alternatively, we can also use the commented codes below to directly convert to ppp
# origin_ppp <- as.ppp(origin)
# destination_ppp <- as.ppp(destination)
```

Plot it to see how it looks like

```{r}
plot(origin_ppp)
plot(destination_ppp)
```

We can check for duplicates
```{r}
any(duplicated(origin_ppp))
any(duplicated(destination_ppp))
```
Since both origin_ppp and destination_ppp doesn't have duplicates, we can move on to the next step

## 3.3 Converting to OWIN Object

We need to convert our sg_sf, which is the Singapore main island's outline, to an OWIN object

```{r}
sg_owin <- as.owin(sg_sf)
plot(sg_owin)
```


## 3.5 Combining point events object and OWIN object

Before performing the analysis, we need to extract only points that are inside Singapore's main island
```{r}
origin_sg <- origin_ppp[sg_owin]
destination_sg <- destination_ppp[sg_owin]
```

Convert it to use kilometres as units, since what we have now is in terms of metres
```{r}
origin_sg_km <- rescale(origin_sg, 1000, 'km')
destination_sg_km <- rescale(destination_sg, 1000, 'km')
```

# 4. KDE

## 4.1 First Order Spatial Point Patterns Analysis

### 4.1.1 KDE with automatic bandwith selection method
We will compare computations using these method:
- bw.diggle()
- bw.CvL()
- bw.scott()
- bw.ppl()

#### Origin
```{r}
kde_origin_diggle <- density(origin_sg_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")

kde_origin_cvl <- density(origin_sg_km,
                              sigma=bw.CvL,
                              edge=TRUE,
                              kernel="gaussian")

kde_origin_scott <- density(origin_sg_km,
                              sigma=bw.scott,
                              edge=TRUE,
                              kernel="gaussian")

kde_origin_ppl <- density(origin_sg_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                              kernel="gaussian")

```
Now we can see the plot for comparison
```{r}
par(mfrow=c(2,2))
plot(kde_origin_diggle, main = "bw.diggle")
plot(kde_origin_cvl, main = "bw.cvl")
plot(kde_origin_scott, main = "bw.scott")
plot(kde_origin_ppl, main = "bw.ppl")
```
#### Destination

```{r}
kde_destination_diggle <- density(destination_sg_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")

kde_destination_cvl <- density(destination_sg_km,
                              sigma=bw.CvL,
                              edge=TRUE,
                              kernel="gaussian")

kde_destination_scott <- density(destination_sg_km,
                              sigma=bw.scott,
                              edge=TRUE,
                              kernel="gaussian")

kde_destination_ppl <- density(destination_sg_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                              kernel="gaussian")

```

Now we can see the plot for comparison

```{r}
par(mfrow=c(2,2))
plot(kde_destination_diggle, main = "bw.diggle")
plot(kde_destination_cvl, main = "bw.cvl")
plot(kde_destination_scott, main = "bw.scott")
plot(kde_destination_ppl, main = "bw.ppl")
```


### 4.1.2 Adaptive Bandwidth KDE

The issue about fixed bandwidth is that less crowded areas, such as countrysides, tends to be less dense compared to more crowded areas like CBDs or city centres. Thus, we can use the adaptive.density() to help overcome this.

```{r}
kde_origin_adaptive <- adaptive.density(origin_sg_km, method="kernel")

kde_destination_adaptive <- adaptive.density(destination_sg_km, method="kernel")
```
We can see the KDE through these plots
```{r}
plot(kde_origin_adaptive)

```

```{r}
plot(kde_destination_adaptive)

```


### 4.1.3 Converting KDE Output to Grid Object

We can convert the output into a grid object for a more suitable mapping without changing the result
```{r}
grid_kde_origin <- as.SpatialGridDataFrame.im(kde_origin_adaptive)
spplot(grid_kde_origin)
```

```{r}
grid_kde_destination <- as.SpatialGridDataFrame.im(kde_destination_adaptive)
spplot(grid_kde_destination)
```
### 4.1.4 Converting Grid to Raster
Next, we will conver the grid to a RasterLayer object using the raster() function

```{r}
kde_origin_raster <- raster(kde_origin_adaptive)
kde_origin_raster

kde_destination_raster <- raster(kde_destination_adaptive)
kde_destination_raster
```
Since there is no crs property on the raster, we can assign it
```{r}
projection(kde_origin_raster) <- CRS("+init=EPSG:3414")
kde_origin_raster

projection(kde_destination_raster) <- CRS("+init=EPSG:3414")
kde_destination_raster
```

### 4.1.5 Visualization
```{r}
tm_shape(kde_origin_raster) + 
  tm_raster("layer") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

```{r}
tm_shape(kde_destination_raster) + 
  tm_raster("layer") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

### 4.1.6 Testing Spatial Point Patterns Using Clark and Evans Test

#### Origin
The test hypotheses are:

Ho = The distribution of grab origin points are randomly distributed.

H1= The distribution of grab origin points are not randomly distributed.

The 95% confident interval will be used.


We can use the CLark-Evans test of aggregation using clarkevans.test() from statspat
```{r}
origin_clarkevans <- clarkevans.test(origin_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"))
origin_clarkevans
```
The Clark-Evans test shows an R value that is much smaller than 1. This means that the points are very close to each other, implying that the points are clustered. The p-value also shows that we can reject the null hyphotesis that the distribution of grab origin points are randomly distributed


#### Destination
The test hypotheses are:

Ho = The distribution of grab destination points are randomly distributed.

H1= The distribution of grab destination points are not randomly distributed.

The 95% confident interval will be used.

```{r}
destination_clarkevans <- clarkevans.test(destination_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"))
destination_clarkevans
```
The Clark-Evans test shows an R value that is much smaller than 1. This means that the points are very close to each other, implying that the points are clustered. The p-value also shows that we can reject the null hyphotesis that the distribution of grab destination points are randomly distributed


## 4.2 Network Constrained Spatial Point Pattern Analysis

For Network Constrained Spatial Point Pattern Analysis, we are taking into account only the roads in Singapore.

### 4.2.1 Preparing Road Objects

First, we prepare an object that contains roads in Singapore. We can use st_within to extract the roads from our dataset from OSM that matches/intersects with the MPSZ. Since we are only looking at roads that is suitable for cars, one way we can do it is by excluding rows where the max speed is 0

```{r}
sg_road <- road_sf[st_contains(sg_sf, road_sf, sparse = FALSE), ] |> filter(maxspeed > 0)
qtm(sg_road)
```

### 4.2.2 NKDE for Origin

First, let's see how it looks like

```{r}
tm_shape(sg_road) + tm_lines() +
  tm_shape(origin) + tm_dots('red', size=0.02)
```

#### 4.2.2.1 Preparing Origin Lixels and Line Centre Points

We will also extract the origin to include only those who are inside the Singapore main island's boundary

```{r}
origin_events <- origin[st_contains(sg_sf, origin, sparse = FALSE), ]
origin_events <- data.frame(origin_events$trj_id, origin_events$geometry) |> st_as_sf(crs=3414)
st_crs(origin_events)
```
Before performing NKDE, we need to cut the sg_road into lixels. In this example, our lixels will have a length of 700 and minimum length of 350
```{r}
origin_lixels <- lixelize_lines(sg_road, 
                         700, 
                         mindist = 350)


origin_samples <- lines_center(origin_lixels)
```


#### 4.2.2.2 Performing NKDE

We will be using nkde.mc(), instead of the usual nkde(). The difference between the two functions is that when paired with the future package, nkde.mc allows for multiple workers to compute the nkde at the same time. We will also set the agg value to 20, which means that points within 20 metres of each other will be aggregrated. The grid_shape will also be set to c(16, 16) to indicate that we are splitting the data to a 16x16 grid that will be computated separately and combined together in the end. All these steps will help in making the runtime of the code a bit faster compared to using the usual default setup.

```{r}
future::plan(future::multisession(workers=4))


origin_densities <- nkde.mc(sg_road, 
                      events = origin_events,
                      w = rep(1,nrow(origin_events)),
                      samples = origin_samples,
                      kernel_name = "quartic",
                      bw = 300,
                      adaptive = TRUE, # we use here an adaptive bandwidth
                      trim_bw = 600, # the maximum local values of bandwidth will be 600m
                      div= "bw",
                      method = "simple", 
                      digits = 1, 
                      tol = 1,
                      grid_shape = c(16,16), 
                      max_depth = 8,
                      agg = 20,
                      sparse = TRUE,
                      verbose = FALSE)

if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

```

#### 4.2.2.3 Insert Densities to Lixel and Sample

After finishing the computation, we need to put the density value into the samples and lixels. Don't forget to adjust the scale to kilometer

```{r}
origin_samples$density <- origin_densities$k
origin_lixels$density <- origin_densities$k

# Rescaling to kilometer
origin_samples$density <- origin_samples$density*1000
origin_lixels$density <- origin_lixels$density*1000
```

#### 4.2.2.4 Visualization
We can use tmaps to visualize the result of our NKDE
```{r}
tm_shape(origin_lixels)+
  tm_lines(col=density)+
tm_shape(origin)+
  tm_dots()
```

### 4.2.3 NKDE for Destination

For destination, we are doing the exact same process, but changing the event points to the destination points.

#### 4.2.3.1 Preparing Destination Lixels and Line Centre Points
```{r}
destination_lixels <- lixelize_lines(sg_road, 
                         700, 
                         mindist = 350)


destination_samples <- lines_center(destination_lixels)
```

```{r}
destination_events <- destination[st_contains(sg_sf, destination, sparse = FALSE), ]
destination_events <- data.frame(destination_events$trj_id, destination_events$geometry) |> st_as_sf(crs=3414)
st_crs(destination_events)
```


#### 4.2.3.2 Performing NKDE
```{r}
future::plan(future::multisession(workers=2))


destination_densities <- nkde.mc(sg_road, 
                      events = destination_events,
                      w = rep(1,nrow(destination_events)),
                      samples = destination_samples,
                      kernel_name = "quartic",
                      bw = 300,
                      adaptive = TRUE, # we use here an adaptive bandwidth
                      trim_bw = 600, # the maximum local values of bandwidth will be 600m
                      div= "bw",
                      method = "simple", 
                      digits = 1, 
                      tol = 1,
                      grid_shape = c(16,16), 
                      max_depth = 8,
                      agg = 20,
                      sparse = TRUE,
                      verbose = FALSE)

if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)
```

#### 4.2.3.3 Insert Densities to Lixel and Sample
```{r}
destination_samples$density <- destination_densities$k
destination_lixels$density <- destination_densities$k

# Rescaling to kilometer
destination_samples$density <- destination_samples$density*1000
destination_lixels$density <- destination_lixels$density*1000
```

#### 4.2.3.4 Visualization
```{r}
tm_shape(destination_lixels)+
  tm_lines()+
tm_shape(destination_samples)+
  tm_dots(density)
```



# 5. Kernel Density Maps on OpenStreetMap

Now we are aiming to plot our kernel density maps on OpenStreetMap to make describing spatial patterns more intuitive.

## 5.1 Defining a Kernel Density Map Function

First, we can create a function called density_map, which can be called later on to visualize our maps.
```{r}
density_map <- function(raster_object, map_title) {
  tm_basemap("OpenStreetMap") +
tm_shape(raster_object) +
  tm_raster("layer", alpha=0.65) + 
  tm_layout(legend.position = c("right", "bottom"), 
            legend.height = 0.5, 
            legend.width = 0.4,
            main.title = map_title,
            main.title.position = 'center',
            main.title.size = 1,
            frame = FALSE)
  } 
```

## 5.2 Plotting Density Map

To plot our density map, we can coll on the density_map function we defined before
```{r}
origin_density_map <- density_map(kde_origin_raster, "GrabPosisi Origin")
origin_density_map

destination_density_map <- density_map(kde_destination_raster, "GrabPosisi Destination")
destination_density_map
```

# Reference

1. https://is415-msty.netlify.app/posts/2021-09-19-take-home-exercise-2/
2. https://rdrr.io/cran/spNetwork/man/nkde.mc.html
3. https://journal.r-project.org/archive/2021/RJ-2021-102/RJ-2021-102.pdf
4. https://r4gdsa.netlify.app/chap07
5. https://r4gdsa.netlify.app/chap04


# Misc
## Saving data to RDS

We can use write_rds() to save our loaded data into an RDS file, making it easier to reload any data we might need again
```{r}
write_rds(origin, 'data/rds/origin.rds')
write_rds(destination, 'data/rds/destination.rds')
write_rds(road_sf, 'data/rds/road_sf.rds')
write_rds(mpsz2019_sf, 'data/rds/mpsz2019_sf.rds')
write_rds(origin_lixels, 'data/rds/origin_lixels.rds')
write_rds(destination_lixels, 'data/rds/destination_lixels.rds')
write_rds(origin_samples, 'data/rds/origin_samples.rds')
write_rds(destination_samples, 'data/rds/destination_samples.rds')
write_rds(sg_road, 'data/rds/sg_road.rds')
write_rds(origin_densities, 'data/rds/origin_densities.rds')
write_rds(destination_densities, 'data/rds/destination_densities.rds')


```

## Loading data from RDS

We can se read_rds() to reload any saved RDS file
```{r}
origin <- read_rds('data/rds/origin.rds')
destination <- read_rds('data/rds/destination.rds')
road_sf <- read_rds('data/rds/road_sf.rds')
mpsz2019_sf <- read_rds('data/rds/mpsz2019_sf.rds')
sg_sf <- read_rds('data/rds/sg_sf.rds')
origin_densities <- read_rds('data/rds/origin_densities.rds')
destination_densities <- read_rds('data/rds/destination_densities.rds')
origin_lixels <- read_rds('data/rds/origin_lixels.rds')
destination_lixels <- read_rds('data/rds/destination_lixels.rds')
origin_samples <- read_rds('data/rds/origin_samples.rds')
destination_samples <- read_rds('data/rds/destination_samples.rds')
```



