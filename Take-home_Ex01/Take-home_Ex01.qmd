---
title: "Take-home Exercise 1: Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore"
author: "Yozafard Harold Siauheming"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      message = TRUE,
                      warning = FALSE,
                      fig.retina = 3)
```

#1. Overview 

## 1.1 Background Human mobility, the movement of human beings in space and time, reflects the spatial-temporal characteristics of human behavior. With the advancement Information and Communication Technologies (ICT) especially smart phone, a large volume of data related to human mobility have been collected. By using appropriate GIS analysis methods, these data are potentially useful in supporting smart city planning and management.

In Singapore, one of the important source of data related to human mobility is from [Land Transport Authority (LTA) DataMall](https://datamall.lta.gov.sg/content/datamall/en.html). Two data sets related to human mobility are provided by the portal, they are: Passenger Volume by Origin Destination Train Stations and Passenger Volume by Origin Destination Bus Stops. One of the limitation of these data sets is that their location are biased to either bus stops or MRT/LRT stations. In 2020, another very interesting human mobility data set called [Grab Posisi](https://engineering.grab.com/grab-posisi) was released by GRAB, one of the largest shared taxi operator in South-east Asia. There are two data sets been released and one of them is for Singapore.

## 1.2 Objectives

Geospatial analytics hold tremendous potential to address complex problems facing society. In this study, you are tasked to apply appropriate spatial point patterns analysis methods to discover the geographical and spatio-temporal distribution of Grab hailing services locations in Singapore.

## 1.3 Tasks

The specific tasks of this take-home exercise are as follows:

-   Using appropriate function of sf and tidyverse, preparing the following geospatial data layer in sf tibble data.frames:
    -   Grab taxi location points either by origins or destinations.
    -   Road layer within Singapore excluding outer islands.
    -   Singapore boundary layer excluding outer islands

-   Using the extracted data, derive traditional Kernel Density Estimation layers.

-   Using the extracted data, derive either Network Kernel Density Estimation (NKDE) or Temporal Network Kernel Density Estimation (TNKDE)

-   Using appropriate tmap functions, display the kernel density layers on openstreetmap of Singapore.

-   Describe the spatial patterns revealed by the kernel density maps.

# 2. Packages

The R packages used in this project are: - sf: for importing, managing, and processing geospatial data. - tidyverse: a family of other R packages for performing data science tasks such as importing, wrangling, and visualising data. - tmap: creating thematic maps - maptools: a set of tools for manipulating geographic data - raster: reads, writes, manipulates, analyses, and model gridded spatial data (raster) - spatstat: for performing spatial point patterns analysis - spNetwork: for performing spatial analysis on network - arrow: to read parquet files

We can load these packages with this code chunk:

```{r}
pacman::p_load(sf, spNetwork, tmap, arrow, tidyverse, spatstat, maptools, data.table)
```

# 3. Data

Aspatial: - [Grab-Posisi](https://engineering.grab.com/grab-posisi) Singapore

Geospatial: - Road data from OpenStreetMap of Geofabrik download server, - Master Plan 2019 Subzone Boundary (No Sea) [from Data.gov.sg](data.gov.sg)

## 3.1 Loading datasets

### 3.1.1 Grab-Posisi

We can load all the Grab-Posisi datasets with this code chunk:

```{r}
file_list <- list.files('./data/GrabPosisi')

combined <- list()
for(i in seq(file_list)) {
  data_name <- paste0('grabposisi', i - 1)
  temp <- read_parquet(paste0('data/GrabPosisi/', file_list[i]))
  combined[[i]] <- temp
}

#Combine all datasets
grabposisi <- bind_rows(combined)
```

```{r}
# file_list <- list.files('./data/GrabPosisi')
# grabposisi <- read_parquet(paste0('data/GrabPosisi/', file_list[1]))
```

Now, we explore the grabposisi data

```{r}
glimpse(grabposisi)
```

We noticed that pingtimestamp is an integer field, so we need to convert pingtimestamp field to a datetime format (POCIXCT)

```{r}
grabposisi$pingtimestamp <- as_datetime(grabposisi$pingtimestamp)
```

Now, we convert it into a geospatial data and add a coordinate reference system

```{r}
grabposisi_sf <- st_as_sf(grabposisi, coords=c("rawlng", "rawlat"), crs=4326) |> st_transform(3414)
st_crs(grabposisi_sf)

```

Now we can check how it looks like by plotting it. To make the computations faster, we can take some sample since we are not doing in-depth analysis at this time.

Making the sample:
```{r}
grabposisi_sample <- grabposisi_sf[seq(1, nrow(grabposisi_sf), by = 300), ]
summary(grabposisi_sample)
```

Making the plot:
```{r}
tm_shape(grabposisi_sample) + tm_dots()
```
Now, we can extract the origin of a ride, based on trajectory id. We will group the rows based on trajectory id, and sort it in ascending order based on the timestamp. The first index of every trajectory id will be the starting point of that ride.

```{r}
# Convert your sf object to a data.table
setDT(grabposisi_sf)

# Pre-calculate date parts to avoid calling them for each row inside mutate
grabposisi_sf[, `:=`(
  weekday = wday(pingtimestamp),
  starting_hour = factor(hour(pingtimestamp)),
  day = factor(mday(pingtimestamp))
)]

# Perform the operations (group, arrange, and filter)
origin <- grabposisi_sf[order(trj_id, pingtimestamp)
  ][, .SD[1], by = .(trj_id)
  ] |> st_as_sf()

st_crs(origin)
```

We can apply a similar logic to get the destination. The difference is that we need to sort it in descending order based on the timestamp.

```{r}
# Convert your sf object to a data.table
setDT(grabposisi_sf)

# Pre-calculate date parts to avoid calling them for each row inside mutate
grabposisi_sf[, `:=`(
  weekday = wday(pingtimestamp),
  starting_hour = factor(hour(pingtimestamp)),
  day = factor(mday(pingtimestamp))
)]

# Perform the operations (group, arrange, and filter)
destination <- grabposisi_sf[order(trj_id, -pingtimestamp)
  ][, .SD[1], by = .(trj_id)
  ] |> st_as_sf()

st_crs(destination)
```

```{r}
# tm_shape(origin_sf) + tm_dots() + tm_shape(destination_sf) + tm_dots()
```

### 3.1.2 Geospatial Data

Now, we need to load the geospatial data. Let's start with the 2019 Subzone Master Plan

```{r}
mpsz2019_sf <- st_read(dsn='data/Geospatial/MPSZ-2019', layer='MPSZ-2019') |> st_transform(crs=3414)
st_crs(mpsz2019_sf)
```

```{r}
qtm(mpsz2019_sf)
```
To extract only the main island, we can filter out the surrounding islands with this code chunk below

```{r}
mpsz2019_sf <- mpsz2019_sf[!grepl("ISLAND", mpsz2019_sf$PLN_AREA_N, ignore.case = TRUE), ]
qtm(mpsz2019_sf)
```

Now, we can get the outline of Singapore's main island with st_union()
```{r}
sg_sf <- mpsz2019_sf |> st_union()
plot(sg_sf)

```


After the Master Plan, we can move on to the Road Data Set

```{r}
road_sf <- st_read(dsn = 'data/Geospatial/malaysia-singapore-brunei-latest-free.shp', layer='gis_osm_roads_free_1') |> st_transform(crs=3414)
st_crs(road_sf)
glimpse(road_sf)
```



## 3.2 Converting to PPP

Since KDE requires the point data to be in ppp format, we will convert our origin and destination to ppp
```{r}
origin_ppp <- as.ppp(origin)
destination_ppp <- as.ppp(destination)
```

Plot it to see how it looks like

```{r}
plot(origin_ppp)
plot(destination_ppp)
```

We can check for duplicates
```{r}
any(duplicated(origin_ppp))
any(duplicated(destination_ppp))
```


## 3.3 Converting to OWIN Object

We need to convert our sg_sf, which is the Singapore main island's outline, to an OWIN object

```{r}
sg_owin <- as.owin(sg_sf)
plot(sg_owin)
```


## 3.5 Combining point events object and OWIN object

```{r}
origin_sg <- origin_ppp[sg_owin]
destination_sg <- destination_ppp[sg_owin]
```

Convert it to km
```{r}
origin_sg_km <- rescale(origin_sg, 1000, 'km')
destination_sg_km <- rescale(destination_sg, 1000, 'km')
```

# 4. KDE

## 4.1 First Order Spatial Point Patterns Analysis

### 4.1.1 KDE with automatic bandwith selection method
We will compare computations using these method:
- bw.diggle()
- bw.CvL()
- bw.scott()
- bw.ppl()

#### Origin
```{r}
kde_origin_diggle <- density(origin_sg_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
origin_diggle_bw <- bw.diggle(origin_sg_km)
origin_diggle_bw

kde_origin_cvl <- density(origin_sg_km,
                              sigma=bw.CvL,
                              edge=TRUE,
                              kernel="gaussian")
origin_cvl_bw <- bw.CvL(origin_sg_km)
origin_cvl_bw

kde_origin_scott <- density(origin_sg_km,
                              sigma=bw.scott,
                              edge=TRUE,
                              kernel="gaussian")
origin_scott_bw <- bw.scott(origin_sg_km)
origin_scott_bw

kde_origin_ppl <- density(origin_sg_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                              kernel="gaussian")
origin_ppl_bw <- bw.ppl(origin_sg_km)
origin_ppl_bw

```
Now we can see the plot for comparison
```{r}
par(mfrow=c(2,2))
plot(kde_origin_diggle, main = "bw.diggle")
plot(kde_origin_cvl, main = "bw.cvl")
plot(kde_origin_scott, main = "bw.scott")
plot(kde_origin_ppl, main = "bw.ppl")
```
#### Destination

```{r}
kde_destination_diggle <- density(destination_sg_km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
destination_diggle_bw <- bw.diggle(destination_sg_km)
destination_diggle_bw

kde_destination_cvl <- density(destination_sg_km,
                              sigma=bw.CvL,
                              edge=TRUE,
                              kernel="gaussian")
destination_cvl_bw <- bw.CvL(destination_sg_km)
destination_cvl_bw

kde_destination_scott <- density(destination_sg_km,
                              sigma=bw.scott,
                              edge=TRUE,
                              kernel="gaussian")
destination_scott_bw <- bw.scott(destination_sg_km)
destination_scott_bw

kde_destination_ppl <- density(destination_sg_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                              kernel="gaussian")
destination_ppl_bw <- bw.ppl(destination_sg_km)
destination_ppl_bw

```

Now we can see the plot for comparison

```{r}
par(mfrow=c(2,2))
plot(kde_destination_diggle, main = "bw.diggle")
plot(kde_destination_cvl, main = "bw.cvl")
plot(kde_destination_scott, main = "bw.scott")
plot(kde_destination_ppl, main = "bw.ppl")
```


### 4.1.2 Adaptive Bandwidth KDE

```{r}
kde_origin_adaptive <- adaptive.density(origin_sg_km, method="kernel")

kde_destination_adaptive <- adaptive.density(destination_sg_km, method="kernel")
```

```{r}
plot(kde_origin_adaptive)

```
```{r}
plot(kde_destination_adaptive)

```


## 4.2 Network Constrained Spatial Point Pattern Analysis

For Network Constrained Spatial Point Pattern Analysis, we are taking into account the roads in Singapore.

### 4.2.1 Preparing Road Objects

First, we prepare an object that contains roads in Singapore. We can use st_intersection to extract the roads from our dataset from OSM that matches/intersects with the MPSZ.
```{r}
sg_road <- st_intersection(road_sf, sg_sf) |> st_as_sf()

```
### 4.2.2 NKDE for Origin

#### 4.2.2.1 Preparing Origin Lixels and Line Centre Points
```{r}
origin_lixels <- lixelize_lines(sg_road, 
                         700, 
                         mindist = 350)


origin_samples <- lines_center(origin_lixels)
```

#### 4.2.2.2 Performing NKDE
```{r}
origin_densities <- nkde(road_sf, 
                  events = origin,
                  w = rep(1,nrow(origin)),
                  samples = origin_samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

#### 4.2.2.3 Insert Densities to Lixel and Sample
```{r}
origin_samples$density <- origin_densities
origin_lixels$density <- origin_densities

# Rescaling to kilometer
origin_samples$density <- origin_samples$density*1000
origin_lixels$density <- origin_lixels$density*1000
```

#### 4.2.2.4 Visualization
```{r}
tm_shape(origin_lixels)+
  tm_lines(col="origin_density")+
tm_shape(origin)+
  tm_dots()
```

### 4.2.3 NKDE for Destination

#### 4.2.3.1 Preparing Destination Lixels and Line Centre Points
```{r}
destination_lixels <- lixelize_lines(sg_road, 
                         700, 
                         mindist = 350)


destination_samples <- lines_center(destination_lixels)
```

#### 4.2.3.2 Performing NKDE
```{r}
destination_densities <- nkde(road_sf, 
                  events = destination,
                  w = rep(1,nrow(destination)),
                  samples = destination_samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

#### 4.2.3.3 Insert Densities to Lixel and Sample
```{r}
destination_samples$density <- destination_densities
destination_lixels$density <- destination_densities

# Rescaling to kilometer
destination_samples$density <- destination_samples$density*1000
destination_lixels$density <- destination_lixels$density*1000
```

#### 4.2.3.4 Visualization
```{r}
tm_shape(destination_lixels)+
  tm_lines(col="destination_density")+
tm_shape(destination)+
  tm_dots()
```

# Misc
## Saving data to RDS
```{r}
write_rds(origin, 'data/rds/origin.rds')
write_rds(destination, 'data/rds/destination.rds')
write_rds(road_sf, 'data/rds/road_sf.rds')
write_rds(grabposisi_sf, 'data/rds/grabposisi_sf.rds')
write_rds(mpsz2019_sf, 'data/rds/mpsz2019_sf.rds')
```

## Loading data from RDS
```{r}
origin <- read_rds('data/rds/origin.rds')
destination <- read_rds('data/rds/destination.rds')
road_sf <- read_rds('data/rds/road_sf.rds')
mpsz2019_sf <- read_rds('data/rds/mpsz2019_sf.rds')
```



